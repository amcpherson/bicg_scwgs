---
title: "OV2295 scWGS Analysis"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(RColorBrewer)
library(vroom)
library(ggExtra)
library(grid)
library(factoextra)
library(igraph)
library(scran)
library(bluster)
library(ggbeeswarm)
library(umap)
library(cluster)
library(Homo.sapiens)
library(ggpubr)

Sys.setenv("DISPLAY"=":0.0")
```

## Read copy number data    

This data is available from zenodo and can be downloaded with:
  `wget "https://zenodo.org/record/3445364/files/ov2295_cell_cn.csv.gz"`
  `wget "https://zenodo.org/record/3445364/files/ov2295_cell_metrics.csv.gz"`

```{r message=FALSE}
#metrics = read_csv('/juno/work/shah/tantalus/SC-3441/results/annotation/A90554A_metrics.csv.gz')
#metrics = read_csv('/juno/work/shah/tantalus/SC-3442/results/annotation/A90554B_metrics.csv.gz')
#metrics = vroom('/juno/work/shah/tantalus/SC-2640/results/annotation/A96213A_metrics.csv.gz')
#metrics = vroom("/juno/work/shah/isabl_data_lake/analyses/88/15/8815/results/A96213A_metrics.csv.gz")
metrics = vroom("ov2295_cell_metrics.csv.gz")
metrics %>% head()
```

ggplot cheat sheet: https://github.com/rstudio/cheatsheets/blob/master/data-visualization-2.1.pdf

```{r}
p <- metrics %>%
  mutate(is_s_phase = factor(1)) %>%
  ggplot(mapping = aes(x=quality, y=total_reads, color=is_s_phase)) + 
  geom_point() +
  theme(legend.position = "left")
ggMarginal(p, type="histogram", groupColour=TRUE, groupFill=TRUE)
```
Filter based on a quality threshold of 0.85.

```{r}
metrics = metrics %>% filter(
  quality >= 0.85,
  !(experimental_condition %in% c("GM", "gDNA")),
  sample_id %in% c("SA1090", "SA921", "SA922"))
```

Read in the copy number data.

```{r}
cn = vroom(
#  '/juno/work/shah/tantalus/SC-3441/results/hmmcopy/A90554A_reads.csv.gz',
#  '/juno/work/shah/tantalus/SC-3442/results/hmmcopy/A90554B_reads.csv.gz',
#  '/juno/work/shah/tantalus/SC-2640/results/hmmcopy/A96213A_reads.csv.gz',
  'ov2295_cell_cn.csv.gz',
  col_types = cols(
    chr = col_factor(NULL),
    cell_id = col_factor(NULL)
  ),
  col_select = c(
    chr,
    start,
    end,
    reads,
    copy,
    state,
    cell_id
  )
)
```

Subset by filtered cell ids in the metrics table.

```{r}
cn = cn %>% inner_join(metrics[, c("cell_id", "sample_id")], by = "cell_id")
cn %>% head()
```

## Plot a single cell

Cell plotting function.

```{r}
plot_profile <- function(cn) {
  cols <- c(rev(brewer.pal(n = 3, "Blues"))[1:2], "#CCCCCC", tail(brewer.pal(n = 8, "OrRd"), 6))
  cols <- c(cols, cols[c(9, 9, 9, 9)])
  names(cols) <- 0:12

  cn %>%
    mutate(cn_state = factor(state, names(cols))) %>%
    mutate(chr = factor(chr, levels = c(1:22, "X", "Y"))) %>%
    ggplot() +
    geom_point(mapping = aes(x = start, y = copy, colour = cn_state), size = 0.5) +
    facet_grid(~chr, scales = "free_x", space="free_x", switch = "x") +
    theme(panel.spacing = unit(0.05, "cm")) +
    scale_x_continuous(breaks = c()) +
    scale_color_manual(values = cols, labels = names(cols), drop = FALSE) +
    scale_y_continuous(breaks = seq(0, 8, by = 1), limit = c(0, 8)) +
    xlab('chromosome')
}

plot_cell <- function(cn, plot_cell_id) {
  filter(cn, cell_id == plot_cell_id) %>% plot_profile()
}
```

Diploid cell:

```{r}
plot_cell(cn, "SA1090-A96213A-R30-C61")
```
Tetraploid cell:

```{r}
plot_cell(cn, "SA1090-A96213A-R28-C68")
```

```{r}

plot_heatmap <- function(gr, dist_method = "euclidean"){
  #' plot a heatmap with chromosome boundaries
  #' the order of the rows can be customized here
  #' its a simple distance based clustering
  #'
  #' Adapted from code published by Velazquez-Villarreal et al. (2020):
  #' https://www.nature.com/articles/s42003-020-1044-8
  #'
  #' Uses the very useful ComplexHeatmap package:
  #' https://jokergoo.github.io/ComplexHeatmap-reference/book/
  
  gr <- GenomeInfoDb::sortSeqlevels(gr)
  gr <- sort(gr)

  mat <- as.matrix(GenomicRanges::mcols(gr))
  mat <- t(mat)
  hr <- hclust(get_dist(mat, method = dist_method), method = "average")
  hr = as.dendrogram(hr)
  
  # chromosome boundaries and midpoints for annotation
  chr_ids = GenomicRanges::seqnames(gr)@values
  chr_lengths = GenomicRanges::seqnames(gr)@lengths
  chr_props = chr_lengths / length(gr)
  mids = cumsum(chr_props) - (chr_props / 2)
  boundaries = cumsum(chr_props)
  boundaries = boundaries[1:length(boundaries)-1]
  abline_x = rep(boundaries, each=2)
  abline_y <- rep(c(0,1), times=length(boundaries))
  abline_ids <- rep(1:length(boundaries),each=2)

  #annotation to label chromosomes
  ha_column = ComplexHeatmap::HeatmapAnnotation(cn = function(index) {
    grid.text(chr_ids,x=mids,y=1,just = c("center", "top"),gp=gpar(col="#202020",fontsize=6))
  })
  
  #the main heatmap
  cols <- c(rev(brewer.pal(n = 3, "Blues"))[1:2], "#CCCCCC", tail(brewer.pal(n = 8, "OrRd"), 6))
  cols <- c(cols, cols[c(9, 9, 9, 9)])
  names(cols) <- 0:12

  hm = ComplexHeatmap::Heatmap(
    matrix = mat,
    name = "ploidy",
    col = cols,
    cluster_rows = hr,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    bottom_annotation = ha_column,
    column_title = "CNV heatmap",
    use_raster = TRUE,
  )
  
  ComplexHeatmap::draw(hm, row_dend_side = "left")

  ComplexHeatmap::decorate_heatmap_body("ploidy", {
    grid.polyline(
      x = abline_x,
      y = abline_y,
      id = abline_ids,
      gp = gpar(lty = 1, lwd = 1))
  })
  
  return(list("heatmap" = hm, "matrix" = mat))
}

```


```{r}
gr = cn %>%
  filter(sample_id == "SA1090") %>%
  dplyr::select(chr, start, end, state, cell_id) %>%
  pivot_wider(names_from = cell_id, values_from = state) %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE)

heatmap_info = plot_heatmap(gr)
```

Alternative distance methods can be specified, see the get_dist function from factoextras: https://www.rdocumentation.org/packages/factoextra/versions/1.0.7/topics/dist.

```{r}
heatmap_info = plot_heatmap(gr, dist_method = "pearson")
```

```{r}
metrics %>%
  filter(sample_id == "SA1090") %>%
  ggplot() + geom_point(aes(x=mean_copy, y=total_reads))
```

```{r}
metrics %>%
  filter(sample_id == "SA1090") %>%
  mutate(is_polyploid = mean_copy > 2.5) %>%
  ggplot(aes(x=is_polyploid, y=total_reads)) + geom_boxplot() +
  stat_compare_means(label.x = 1.3)
```

# Clustering

We will cluster based on raw data (copy).

There is a great tutorial here: https://bioconductor.org/books/release/OSCA/clustering.html

First try a k-means cluster and plot a umap projection:

```{r message=FALSE}
gr = cn %>%
  dplyr::select(chr, start, end, copy, cell_id) %>%
  pivot_wider(names_from = cell_id, values_from = copy) %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE)

# Remove bins with any nan across any cell
gr = gr[complete.cases(GenomicRanges::mcols(gr))]

# Create matrix, remove bins that are nan across any cells
mat <- as.matrix(GenomicRanges::mcols(gr))

# Optionally normalize the copy number, this will group cells regardless of ploidy
mat <- scale(mat)

mat <- t(mat)

# k means clustering on top 100 pca components, use 10 restarts, set seed for consistency
set.seed(42)
mat.pca <- prcomp(mat)
clust.kmeans <- kmeans(mat.pca$x[, 1:100], centers=20, nstart=10)
clust = clust.kmeans$cluster

# umap plot
mat.umap = umap(mat)
mat.umap.tbl = tibble(x=mat.umap$layout[,1], y=mat.umap$layout[,2], cluster=factor(clust))
```

```{r}
ggplot(mat.umap.tbl) + geom_point(aes(x=x, y=y, color=cluster))
```

PCA, but probably wont keep:

```{r}
pc = "PC1"

gr.pca <- granges(gr)
GenomicRanges::mcols(gr.pca) <- list(PC=mat.pca$rotation[, pc])

GenomicRanges::as.data.frame(gr.pca) %>%
  tibble() %>%
  dplyr::rename(chr=seqnames) %>%
  ggplot() +
  geom_point(mapping = aes(x = start, y = PC), size = 0.5) +
  facet_grid(~chr, scales = "free_x", space="free_x", switch = "x") +
  theme(panel.spacing = unit(0.05, "cm")) +
  scale_x_continuous(breaks = c()) +
  xlab('chromosome')
```

Use the gap statistic to select the best k.

```{r message=FALSE, eval=FALSE}
gaps <- clusGap(mat, kmeans, K.max=20, B=10)
best.k <- maxSE(gaps$Tab[,"gap"], gaps$Tab[,"SE.sim"])
best.k

plot(gaps$Tab[,"gap"], xlab="Number of clusters", ylab="Gap statistic")
abline(v=best.k, col="red")
```

We can also assess the clustering using the silhouette method.

```{r}
sil.approx <- approxSilhouette(mat, clusters=clust)

sil.data <- as.data.frame(sil.approx)
sil.data$closest <- factor(ifelse(sil.data$width > 0, clust, sil.data$other))
sil.data$cluster <- factor(clust)

ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) + 
    ggbeeswarm::geom_quasirandom(method="smiley")
```

As an alternative, lets try a graph based clustering approach.

```{r eval=FALSE}
d = get_dist(mat, method = "euclidean")

# graph based clustering
set.seed(42)
mat.pca <- prcomp(mat)
g <- buildSNNGraph(t(mat.pca), k=10, type="number")
clust <- igraph::cluster_walktrap(g)$membership
table(clust)

# umap plot
mat.umap = umap(mat)
mat.umap.tbl = tibble(x=mat.umap$layout[,1], y=mat.umap$layout[,2], cluster=factor(clust))
ggplot(mat.umap.tbl) + geom_point(aes(x=x, y=y, color=cluster))

# silhouette width evaluation
sil.approx <- approxSilhouette(mat, clusters=clust)
sil.data <- as.data.frame(sil.approx)
sil.data$closest <- factor(ifelse(sil.data$width > 0, clust, sil.data$other))
sil.data$cluster <- factor(clust)
ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) + 
    ggbeeswarm::geom_quasirandom(method="smiley")
```

```{r}
plot_cluster_heatmap <- function(gr, clust){
  #' plot a heatmap with chromosome boundaries
  #' the order of the rows can be customized here
  #' its a simple distance based clustering
  #'
  #' Adapted from code published by Velazquez-Villarreal et al. (2020):
  #' https://www.nature.com/articles/s42003-020-1044-8
  #'
  #' Uses the very useful ComplexHeatmap package:
  #' https://jokergoo.github.io/ComplexHeatmap-reference/book/
  
  gr <- GenomeInfoDb::sortSeqlevels(gr)
  gr <- sort(gr)

  sorted_clust = sort(clust)

  mat <- as.matrix(GenomicRanges::mcols(gr))
  mat <- t(mat)
  mat <- mat[names(sorted_clust),]
  
  # chromosome boundaries and midpoints for annotation
  chr_ids = GenomicRanges::seqnames(gr)@values
  chr_lengths = GenomicRanges::seqnames(gr)@lengths
  chr_props = chr_lengths / length(gr)
  mids = cumsum(chr_props) - (chr_props / 2)
  boundaries = cumsum(chr_props)
  boundaries = boundaries[1:length(boundaries)-1]
  abline_x = rep(boundaries, each=2)
  abline_y <- rep(c(0,1), times=length(boundaries))
  abline_ids <- rep(1:length(boundaries),each=2)

  # annotation to label chromosomes
  ha_column = ComplexHeatmap::HeatmapAnnotation(cn = function(index) {
    grid.text(chr_ids,x=mids,y=1,just = c("center", "top"),gp=gpar(col="#202020",fontsize=6))
  })

  # cluster annotation
  cluster_colors = rainbow(length(unique(sorted_clust)))
  names(cluster_colors) = unique(sorted_clust)
  ha_row = ComplexHeatmap::rowAnnotation(cluster = factor(sorted_clust), col = list(cluster = cluster_colors))

  # the main heatmap
  cols <- c(rev(brewer.pal(n = 3, "Blues"))[1:2], "#CCCCCC", tail(brewer.pal(n = 8, "OrRd"), 6))
  cols <- c(cols, cols[c(9, 9, 9, 9)])
  names(cols) <- 0:12

  hm = ComplexHeatmap::Heatmap(
    matrix = mat,
    name = "ploidy",
    col = cols,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    bottom_annotation = ha_column,
    left_annotation = ha_row,
    column_title = "CNV heatmap",
    use_raster = TRUE,
  )
  
  ComplexHeatmap::draw(hm)

  ComplexHeatmap::decorate_heatmap_body("ploidy", {
    grid.polyline(
      x = abline_x,
      y = abline_y,
      id = abline_ids,
      gp = gpar(lty = 1, lwd = 1))
  })
  
  return(list("heatmap" = hm, "matrix" = mat))
}
```

```{r}
gr = cn %>%
  dplyr::select(chr, start, end, state, cell_id) %>%
  pivot_wider(names_from = cell_id, values_from = state) %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE)

plot_cluster_heatmap(gr, clust)
```

Create merged cluster level copy number:

```{r}
clust.df <- enframe(clust.kmeans$cluster) %>%
  dplyr::rename(cell_id = name, cluster = value)

clust.sizes <- enframe(table(clust.df$cluster)) %>%
  dplyr::rename(cell_id = name, size = value) %>%
  filter(size >= 10)

cn_clust <- cn %>%
  inner_join(clust.df) %>%
  group_by(chr, start, end, cluster) %>%
  summarize(copy = mean(copy), state = median(state))
```

```{r}
cn_clust %>% filter(cluster == 1) %>% plot_profile()
cn_clust %>% filter(cluster == 2) %>% plot_profile()
cn_clust %>% filter(cluster == 3) %>% plot_profile()
```

There appears to be a deletion on chromosome 5.  Navigate here to see why:
http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&lastVirtModeType=default&lastVirtModeExtraState=&virtModeType=default&virtMode=0&nonVirtPosition=&position=chr5%3A67500000%2D72000002&hgsid=1117136619_dGtW3EEOeJAIG6cYbSGFZwGwyLzb







```{r}
subset.gr = cn_clust %>% filter(copy < 0.2, chr != "Y") %>% makeGRangesFromDataFrame()
subset.gr
```

```{r}
cencus.amps = read_csv('Census_ampThu\ Apr\ 16\ 15_35_36\ 2020.csv') %>%
  dplyr::rename(symbol = `Gene Symbol`)

# read human genes, normalize chromosome names
human.genes = genes(TxDb.Hsapiens.UCSC.hg19.knownGene) %>%
  renameSeqlevels(sub("chr", "", seqlevels(human.genes)))

# add gene symbol from org.Hs.egSYMBOL
GenomicRanges::mcols(human.genes) = tibble(gene_id=human.genes$gene_id) %>%
  left_join(tibble(as.data.frame(org.Hs.egSYMBOL)))

# subset by cancer gene cencus amps
cencus.amps.genes = human.genes[(elementMetadata(human.genes)[,'symbol'] %in% cencus.amps$symbol)]

subset.gr = cn_clust %>% filter(copy > 10) %>% makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE)
subset.genes = subsetByOverlaps(cencus.amps.genes, subset.gr)

all.gr = cn_clust %>% makeGRangesFromDataFrame(keep.extra.columns=TRUE,ignore.strand=TRUE)
subsetByOverlaps(all.gr, subset.genes) %>%
  as_tibble() %>%
  ggplot() + geom_col(aes(x=factor(cluster), y=copy))
```




GenomicRanges::mcols(subset.genes) = GenomicRanges::mcols(subset.genes) %>%


subsetByOverlaps(genes(TxDb.Hsapiens.UCSC.hg19.knownGene), subset.gr)

genes(TxDb.Hsapiens.UCSC.hg19.knownGene)



Select a cell then plot normalized binned reads across the genome.

```{r plotsingle, echo=FALSE, eval=FALSE}
cell = filter(cn, cell_id == "SA922-A90554B-R35-C19")

cell$chr <- factor(cell$chr, levels = c(1:22, "X", "Y"))

cols <- c(rev(brewer.pal(n = 3, "Blues"))[1:2], "#CCCCCC", tail(brewer.pal(n = 8, "OrRd"), 6))
cols <- c(cols, cols[c(9, 9, 9, 9)])
names(cols) <- 0:12

cell$cn_state = factor(cell$state, names(cols))

ggplot(data = cell) +
  geom_point(mapping = aes(x = start, y = copy, colour = cn_state), size = 0.5) +
  facet_grid(~chr, scales = "free_x", space="free_x", switch = "x") +
  theme(panel.spacing = unit(0.05, "cm")) +
  scale_x_continuous(breaks = c()) +
  scale_color_manual(values = cols, labels = names(cols), drop = FALSE) +
  scale_y_continuous(breaks = seq(0, 18, by = 2), limit = c(0, 12)) +
  xlab('chromosome')
```

## Exploring cells with different properties

Lets make a function out of our cell plotting code and use it to plot cells with different properties.

```{r plotfunc, echo=FALSE, eval=FALSE}
plot_profile <- function(cn, plot_cell_id) {
  cell$chr <- factor(cell$chr, levels = c(1:22, "X", "Y"))

  cols <- c(rev(brewer.pal(n = 3, "Blues"))[1:2], "#CCCCCC", tail(brewer.pal(n = 8, "OrRd"), 6))
  cols <- c(cols, cols[c(9, 9, 9, 9)])
  names(cols) <- 0:12

  cell$cn_state = factor(cell$state, names(cols))

  ggplot(data = cell) +
    geom_point(mapping = aes(x = start, y = copy, colour = cn_state), size = 0.5) +
    facet_grid(~chr, scales = "free_x", space="free_x", switch = "x") +
    theme(panel.spacing = unit(0.05, "cm")) +
    scale_x_continuous(breaks = c()) +
    scale_color_manual(values = cols, labels = names(cols), drop = FALSE) +
    scale_y_continuous(breaks = seq(0, 18, by = 2), limit = c(0, 12)) +
    xlab('chromosome')
}

plot_cell <- function(cn, plot_cell_id) {
  cell = filter(cn, cell_id == plot_cell_id)
  plot_profile(cell)
}
```

A cell with very low coverage:

```{r echo=FALSE, eval=FALSE}
plot_cell(cn, "SA922-A90554B-R23-C39")
```
A low quality cell:

```{r echo=FALSE, eval=FALSE}
plot_cell(cn, "SA922-A90554B-R23-C03")
```

A cell in s-phase:

```{r echo=FALSE, eval=FALSE}
plot_cell(cn, "SA922-A90554B-R23-C64")
```
Note that 

```{r echo=FALSE, eval=FALSE}
cn %>% filter(cell_id == "SA922-A90554B-R27-C22", gc > 0) %>%
  ggplot() +
  geom_point(mapping = aes(x = gc, y = reads, colour = state), size = 0.5)
```

A cell with catastophic mitotic error including complete loss of 9q.

```{r echo=FALSE, eval=FALSE}
plot_cell(cn, "SA922-A90554B-R23-C38")
```
A cell in s-phase.

```{r echo=FALSE, eval=FALSE}
plot_cell(cn, "SA922-A90554B-R23-C64")
```


low coverage: SA922-A90554B-R23-C39

low coverage: SA922-A90554B-R23-C03

low coverage: SA922-A90554B-R23-C03


```{r eval=FALSE}
ggplot(data = cell) +
  geom_rect(mapping = aes(xmin = start, xmax=end, ymin = copy - 0.2, ymax=copy + 0.2), color="black", fill="white") +
  facet_grid(~chr, scales = "free_x", space="free_x", switch = "x") +
  theme(panel.spacing = unit(0.05, "cm")) +
  scale_x_continuous(breaks = c()) +
  scale_y_continuous(breaks = seq(0, 18, by = 2), limit = c(0, 12)) +
  xlab('chromosome')
```




